sort(boot2$supLMj)
mean(qq[1,])
mean(qq[2,])
boot2 <- score_test_tarpq_j(g_lm$supLM, lin2$coeflin, 20, 100, y2, W2, p=1, d=1,
Z=NULL, J=199, L=1, U=1.5)
boot2      ## test with bootstrap, by optimizing the test at each j
boot2$cpJ
boot2 <- score_test_tarpq_j(g_lm$supLM, lin2$coeflin, 20, 100, y2, W2, p=1, d=1,
Z=NULL, J=199, L=0.001, U=1.5)
boot2      ## test with bootstrap, by optimizing the test at each j
boot2 <- score_test_tarpq_j(g_lm$supLM, lin2$coeflin, 20, 100, y2, W2, p=1, d=1,
Z=NULL, J=199, L=0.001, U=1)
boot2      ## test with bootstrap, by optimizing the test at each j
boot2 <- score_test_tarpq_j(g_lm$supLM, lin2$coeflin, 20, 100, y2, W2, p=1, d=1,
Z=NULL, J=199, L=0.01, U=1.5)
boot2      ## test with bootstrap, by optimizing the test at each j
save.image("C:/Users/marmil01/Desktop/R package PNAR/Lag p and covariates/test_TNAR.RData")
library(igraph)
library(copula)
library(nloptr)
mean(qq[1,])
mean(qq[2,])
g_lm  ## optimal value gamma, sup test and intervals
boot2$pJ
boot2$cpJ
mean(qq3[1,])
mean(qq3[2,])
g_lm3  ## optimal value gamma, sup test and intervals
g_lm3.2
boot3.3$pJ
boot3.4$pJ
mean(qq[1,])
mean(qq[2,])
DV
mean(qq[1,])
mean(qq[2,])
g_lm  ## optimal value gamma, sup test and intervals
boot2$cpJ
mean(qq3[1,])
mean(qq3[2,])
boot3.4$pJ
boot3.3$pJ
mean(qq0[1,])
mean(qq0[2,])
boot0$cpJ
mean(qq4[1,])
mean(qq4[2,])
g_lm4  ## optimal value gamma, sup test and intervals
g_lm4.2
boot5$pJ
boot5.2$pJ
Z3=W2%*%y3
qq3 <- matrix(0, 2, nrow(Z3))
for (k in 1:nrow(Z3)){
qq3[,k] <- as.matrix(quantile(Z3[k,], prob=c(0.20, 0.80)))
}
mean(qq3[1,])
mean(qq3[2,])
mean(qq[1,])
mean(qq[2,])
Z2=W2%*%y2
qq <- matrix(0, 2, nrow(Z2))
for (k in 1:nrow(Z2)){
qq[,k] <- as.matrix(quantile(Z2[k,], prob=c(0.20, 0.80)))
}
mean(qq[1,])
mean(qq[2,])
Z3=W2%*%y3
qq3 <- matrix(0, 2, nrow(Z3))
for (k in 1:nrow(Z3)){
qq3[,k] <- as.matrix(quantile(Z3[k,], prob=c(0.20, 0.80)))
}
mean(qq3[1,])
mean(qq3[2,])
Z3=W2%*%y3
qq3 <- matrix(0, 2, nrow(Z3))
for (k in 1:nrow(Z3)){
qq3[,k] <- as.matrix(quantile(Z3[k,], prob=c(0.15, 0.80)))
}
mean(qq3[1,])
mean(qq3[2,])
Z3=W2%*%y3
qq3 <- matrix(0, 2, nrow(Z3))
for (k in 1:nrow(Z3)){
qq3[,k] <- as.matrix(quantile(Z3[k,], prob=c(0.20, 0.80)))
}
mean(qq3[1,])
mean(qq3[2,])
g_lm3 <- global_optimise_LM(f=LM_gamma_tpnarpq, L=mean(qq3[1,]), U=mean(qq3[2,]), I=2, lin3$coeflin, NN, T1,
y3, W2, p=2, d=1, Z=Z)
g_lm3  ## optimal value gamma, sup test and intervals
g_lm3 <- global_optimise_LM(f=LM_gamma_tpnarpq, L=0.5, U=mean(qq3[2,]), I=2, lin3$coeflin, NN, T1,
y3, W2, p=2, d=1, Z=Z)
g_lm3  ## optimal value gamma, sup test and intervals
LM_gamma_tpnarpq(1, lin3$coeflin, NN, T1,
y3, W2, p=2, d=1, Z=Z)
g_lm3 <- global_optimise_LM(f=LM_gamma_tpnarpq, L=mean(qq3[1,]), U=mean(qq3[2,]), I=2, lin3$coeflin, NN, T1,
y3, W2, p=2, d=1, Z=Z)
g_lm3  ## optimal value gamma, sup test and intervals
boot3.3$pJ
boot3.4$pJ
mean(qq0[1,])
mean(qq0[2,])
boot0$cpJ
mean(qq4[1,])
mean(qq4[2,])
g_lm4  ## optimal value gamma, sup test and intervals
g_lm4.2
boot5$pJ
boot5.2$pJ
boot5.2$cpJ
boot5$cpJ
library(igraph)
library(copula)
set.seed(123)
adja <- function(N, K, alpha){
p_in=alpha*N^(-0.3)            # probability of an edge between nodes in same block
p_out=alpha*N^(-1)             # probability of an edge between nodes in different blocks
pm <- matrix(p_out, nrow=K, ncol=K)
diag(pm) <- p_in
# generate randomly a SBM network
gra <- sample_sbm(n=N, pref.matrix=pm, block.sizes=rep(N/K, K), directed = TRUE)
A <- as_adjacency_matrix(gra, sparse=FALSE)  #generate adjacency matrix
D <- diag(rowSums(A)^(-1))
D[which(D==Inf)] <- 0
W <- D%*%A                    #generate row-normalized adjacency matrix
return(W)
}
adja_gnp <- function(N, alpha){
# generate randomly a ER network
gra <- sample_gnp(N, p=alpha*N^(-0.3), directed = TRUE, loops = FALSE)
A <- as_adjacency_matrix(gra, sparse=FALSE)  #generate adjacency matrix
D <- diag(rowSums(A)^(-1))
D[which(D==Inf)] <- 0
W <- D%*%A                        #generate row-normalized adjacency matrix                  #generate row-normalized adjacency matrix
return(W)
}
getN = function(x,tt=1) {
if(sum(x)<tt)
return(NA)
if(x[1]>tt)
return(0)
else
return(max(which(cumsum(x)<=tt)))
}
poisson.MODpq.nonlin <- function(b, W, gamma, p, d, Z, Time, N, copula, rho, df)
{
p2R <- rho^(1:(N-1))      ### creates column vectors of corr matrix R=(rho^|i-j|)_(i,j),
R=toeplitz(c(1,p2R))      ### this is a symmetric Toeplitz matrix
y=matrix(NA, nrow=N, ncol=Time)
c=matrix(NA, nrow=N, ncol=Time)
lambda=matrix(NA, nrow=N, ncol=Time)
lambda[,1:p]=rep(1, N)
for( t in 1:p){
if(copula=="gaussian") ustart=rCopula(100, normalCopula(param=p2R, dispstr = "toep", dim=N))
if(copula=="gaussian_rho") ustart=rCopula(100, normalCopula(rho, dim = N))
if(copula=="student") ustart=rCopula(100, tCopula(param=p2R, dispstr = "toep", df=df, dim=N))
if(copula=="clayton") ustart=rCopula(100, claytonCopula(rho, dim = N))
xstart <- matrix(nrow=100, ncol=N)
xstart  =t(t(-log(ustart))/lambda[,t])
y[,t] <-  apply(xstart,2, getN, tt=1)
c[,t] <- 1/(1+W%*%y[,t])^gamma
}
for (t in (p+1):Time){
X <- cbind(W%*%y[,(t-1):(t-p)], y[,(t-1):(t-p)], Z)
lambda[,t]=b[1]*c[,t-d]+X%*%b[-1]
if(copula=="gaussian") u=rCopula(100, normalCopula(param=p2R, dispstr = "toep", dim=N))
if(copula=="gaussian_rho") u=rCopula(100, normalCopula(rho, dim = N))
if(copula=="student") u=rCopula(100, tCopula(param=p2R, dispstr = "toep", df=df, dim=N))
if(copula=="clayton") u=rCopula(100, claytonCopula(rho, dim = N))
x <- matrix(nrow=100, ncol=N)
x =t(t(-log(u))/lambda[ ,t])
y[,t] <- apply(x,2, getN,tt=1)
c[,t] <- 1/(1+W%*%y[,t])^gamma
}
res <- list(lambda=lambda, y=y, p2R=p2R)
return(res)
}
poisson.MODpq.star <- function(b, W, gamma, a, p, d, Z, Time, N, copula, rho, df)
{
p2R <- rho^(1:(N-1))      ### creates column vectors of corr matrix R=(rho^|i-j|)_(i,j),
R=toeplitz(c(1,p2R))      ### this is a symmetric Toeplitz matrix
y=matrix(NA, nrow=N, ncol=Time)
c=matrix(NA, nrow=N, ncol=Time)
lambda=matrix(NA, nrow=N, ncol=Time)
lambda[,1:p]=rep(1, N)
for( t in 1:p){
if(copula=="gaussian") ustart=rCopula(100, normalCopula(param=p2R, dispstr = "toep", dim=N))
if(copula=="gaussian_rho") ustart=rCopula(100, normalCopula(rho, dim = N))
if(copula=="student") ustart=rCopula(100, tCopula(param=p2R, dispstr = "toep", df=df, dim=N))
if(copula=="clayton") ustart=rCopula(100, claytonCopula(rho, dim = N))
xstart <- matrix(nrow=100, ncol=N)
xstart  =t(t(-log(ustart))/lambda[,t])
y[,t] <-  apply(xstart,2, getN, tt=1)
c[,t] <- exp(-gamma*(W%*%y[,t]*W%*%y[,t]))
}
for (t in (p+1):Time){
X <- cbind(1, W%*%y[,(t-1):(t-p)], y[,(t-1):(t-p)], Z)
lambda[,t]=X%*%b+c[,t-d]*W%*%y[,(t-1):(t-p)]%*%a
if(copula=="gaussian") u=rCopula(100, normalCopula(param=p2R, dispstr = "toep", dim=N))
if(copula=="gaussian_rho") u=rCopula(100, normalCopula(rho, dim = N))
if(copula=="student") u=rCopula(100, tCopula(param=p2R, dispstr = "toep", df=df, dim=N))
if(copula=="clayton") u=rCopula(100, claytonCopula(rho, dim = N))
x <- matrix(nrow=100, ncol=N)
x =t(t(-log(u))/lambda[ ,t])
y[,t] <- apply(x,2, getN,tt=1)
c[,t] <- exp(-gamma*(W%*%y[,t]*W%*%y[,t]))
}
res <- list(lambda=lambda, y=y, p2R=p2R)
return(res)
}
poisson.MODpq.tar <- function(b, W, gamma, a, p, d, Z, Time, N, copula, rho, df)
{
p2R <- rho^(1:(N-1))      ### creates column vectors of corr matrix R=(rho^|i-j|)_(i,j),
R=toeplitz(c(1,p2R))      ### this is a symmetric Toeplitz matrix
y=matrix(NA, nrow=N, ncol=Time)
c=matrix(NA, nrow=N, ncol=Time)
lambda=matrix(NA, nrow=N, ncol=Time)
lambda[,1:p]=rep(1, N)
for( t in 1:p){
if(copula=="gaussian") ustart=rCopula(100, normalCopula(param=p2R, dispstr = "toep", dim=N))
if(copula=="gaussian_rho") ustart=rCopula(100, normalCopula(rho, dim = N))
if(copula=="student") ustart=rCopula(100, tCopula(param=p2R, dispstr = "toep", df=df, dim=N))
if(copula=="clayton") ustart=rCopula(100, claytonCopula(rho, dim = N))
xstart <- matrix(nrow=100, ncol=N)
xstart  =t(t(-log(ustart))/lambda[,t])
y[,t] <-  apply(xstart,2, getN, tt=1)
c[,t] <- 0+(W%*%y[,t]<=gamma)
}
for (t in (p+1):Time){
X <- cbind(1, W%*%y[,(t-1):(t-p)], y[,(t-1):(t-p)], Z)
lambda[,t]=X%*%b+X[,1:(1+2*p)]%*%a*c[,t-d]
if(copula=="gaussian") u=rCopula(100, normalCopula(param=p2R, dispstr = "toep", dim=N))
if(copula=="gaussian_rho") u=rCopula(100, normalCopula(rho, dim = N))
if(copula=="student") u=rCopula(100, tCopula(param=p2R, dispstr = "toep", df=df, dim=N))
if(copula=="clayton") u=rCopula(100, claytonCopula(rho, dim = N))
x <- matrix(nrow=100, ncol=N)
x =t(t(-log(u))/lambda[ ,t])
y[,t] <- apply(x,2, getN,tt=1)
c[,t] <- 0+(W%*%y[,t]<=gamma)
}
res <- list(lambda=lambda, y=y, p2R=p2R)
return(res)
}
W <- adja(20, 2, 0.1)
W
poisson.MODpq.tar(b=c(0.5, 0.3, 0.2), W, gamma=0.5, a=0.2, p=1, d=1, Z=NULL,
Time=100, N=20, copula="gaussian", rho=0.5, df=1)
poisson.MODpq.tar(b=c(0.5, 0.3, 0.2), W=W, gamma=0.5, a=0.2, p=1, d=1, Z=NULL,
Time=100, N=20, copula="gaussian", rho=0.5, df=1)
N <- 20
rho <- 0.5
p2Rr <- rho^(1:(N-1))      ### creates column vectors of corr matrix R=(rho^|i-j|)_(i,j),
p2Rr
Rr=toeplitz(c(1,p2Rr))      ### this is a symmetric Toeplitz matrix
Rr
Time <- 100
yr=matrix(NA, nrow=N, ncol=Time)
cr=matrix(NA, nrow=N, ncol=Time)
lambda=matrix(NA, nrow=N, ncol=Time)
p=1
lambda[,1:p]=rep(1, N)
lambda
View(lambda)
N <- 20
rho <- 0.5
p2Rr <- rho^(1:(N-1))      ### creates column vectors of corr matrix R=(rho^|i-j|)_(i,j),
Rr=toeplitz(c(1,p2Rr))      ### this is a symmetric Toeplitz matrix
Time <- 100
yr=matrix(NA, nrow=N, ncol=Time)
cr=matrix(NA, nrow=N, ncol=Time)
lambda=matrix(NA, nrow=N, ncol=Time)
p=1
lambda[,1:p]=rep(1, N)
gamma <- 0.5
Z <- NULL
d <- 1
b <- c(0.5, 0.3, 0.2)
a <- 0.2
for( t in 1:p){
ustartr=rCopula(100, normalCopula(param=p2Rr, dispstr = "toep", dim=N))
xstartr <- matrix(nrow=100, ncol=N)
xstartr  =t(t(-log(ustartr))/lambda[,t])
yr[,t] <-  apply(xstartr,2, getN, tt=1)
cr[,t] <- 0+(W%*%yr[,t]<=gamma)
}
for (t in (p+1):Time){
Xr <- cbind(1, W%*%yr[,(t-1):(t-p)], yr[,(t-1):(t-p)], Z)
lambda[,t]=Xr%*%b+Xr[,1:(1+2*p)]%*%a*cr[,t-d]
ur=rCopula(100, normalCopula(param=p2Rr, dispstr = "toep", dim=N))
xr <- matrix(nrow=100, ncol=N)
xr =t(t(-log(ur))/lambda[ ,t])
yr[,t] <- apply(xr,2, getN,tt=1)
cr[,t] <- 0+(W%*%yr[,t]<=gamma)
}
N <- 20
rho <- 0.5
p2Rr <- rho^(1:(N-1))      ### creates column vectors of corr matrix R=(rho^|i-j|)_(i,j),
Rr=toeplitz(c(1,p2Rr))      ### this is a symmetric Toeplitz matrix
Time <- 100
yr=matrix(NA, nrow=N, ncol=Time)
cr=matrix(NA, nrow=N, ncol=Time)
lambda=matrix(NA, nrow=N, ncol=Time)
p=1
lambda[,1:p]=rep(1, N)
gamma <- 0.5
Z <- NULL
d <- 1
b <- c(0.5, 0.3, 0.2)
a <- 0.2
for( t in 1:p){
ustartr=rCopula(100, normalCopula(param=p2Rr, dispstr = "toep", dim=N))
xstartr <- matrix(nrow=100, ncol=N)
xstartr  =t(t(-log(ustartr))/lambda[,t])
yr[,t] <-  apply(xstartr,2, getN, tt=1)
cr[,t] <- 0+(W%*%yr[,t]<=gamma)
}
ustartr
xstartr
yr[,1]
yr[,2]
cr[,2]
cr[,1]
W%*%yr[,1]
p
for (t in (p+1):Time){
Xr <- cbind(1, W%*%yr[,(t-1):(t-p)], yr[,(t-1):(t-p)], Z)
lambda[,t]=Xr%*%b+Xr[,1:(1+2*p)]%*%a*cr[,t-d]
ur=rCopula(100, normalCopula(param=p2Rr, dispstr = "toep", dim=N))
xr <- matrix(nrow=100, ncol=N)
xr =t(t(-log(ur))/lambda[ ,t])
yr[,t] <- apply(xr,2, getN,tt=1)
cr[,t] <- 0+(W%*%yr[,t]<=gamma)
}
N <- 20
rho <- 0.5
p2Rr <- rho^(1:(N-1))      ### creates column vectors of corr matrix R=(rho^|i-j|)_(i,j),
Rr=toeplitz(c(1,p2Rr))      ### this is a symmetric Toeplitz matrix
Time <- 100
yr=matrix(NA, nrow=N, ncol=Time)
cr=matrix(NA, nrow=N, ncol=Time)
lambda=matrix(NA, nrow=N, ncol=Time)
p=1
lambda[,1:p]=rep(1, N)
gamma <- 0.5
Z <- NULL
d <- 1
b <- c(0.5, 0.3, 0.2)
a <- 0.2
for( t in 1:p){
ustartr=rCopula(100, normalCopula(param=p2Rr, dispstr = "toep", dim=N))
xstartr <- matrix(nrow=100, ncol=N)
xstartr  =t(t(-log(ustartr))/lambda[,t])
yr[,t] <-  apply(xstartr,2, getN, tt=1)
cr[,t] <- 0+(W%*%yr[,t]<=gamma)
}
for (t in (p+1):Time){
Xr <- cbind(1, W%*%yr[,(t-1):(t-p)], yr[,(t-1):(t-p)], Z)
lambda[,t]=Xr%*%b+Xr[,1:(1+2*p)]%*%a*cr[,t-d]
ur=rCopula(100, normalCopula(param=p2Rr, dispstr = "toep", dim=N))
xr <- matrix(nrow=100, ncol=N)
xr =t(t(-log(ur))/lambda[ ,t])
yr[,t] <- apply(xr,2, getN,tt=1)
cr[,t] <- 0+(W%*%yr[,t]<=gamma)
}
#for (t in (p+1):Time){
t <- p+1
Xr <- cbind(1, W%*%yr[,(t-1):(t-p)], yr[,(t-1):(t-p)], Z)
Xr
View(Xr)
lambda[,t]=Xr%*%b+Xr[,1:(1+2*p)]%*%a*cr[,t-d]
lambda[,t]=Xr%*%b#+Xr[,1:(1+2*p)]%*%a*cr[,t-d]
lambda[,t]=Xr%*%b+Xr[,1:(1+2*p)]%*%a#*cr[,t-d]
Xr[,1:(1+2*p)]
W <- adja(20, 2, 0.1)
library(igraph)
library(copula)
set.seed(123)
adja <- function(N, K, alpha){
p_in=alpha*N^(-0.3)            # probability of an edge between nodes in same block
p_out=alpha*N^(-1)             # probability of an edge between nodes in different blocks
pm <- matrix(p_out, nrow=K, ncol=K)
diag(pm) <- p_in
# generate randomly a SBM network
gra <- sample_sbm(n=N, pref.matrix=pm, block.sizes=rep(N/K, K), directed = TRUE)
A <- as_adjacency_matrix(gra, sparse=FALSE)  #generate adjacency matrix
D <- diag(rowSums(A)^(-1))
D[which(D==Inf)] <- 0
W <- D%*%A                    #generate row-normalized adjacency matrix
return(W)
}
adja_gnp <- function(N, alpha){
# generate randomly a ER network
gra <- sample_gnp(N, p=alpha*N^(-0.3), directed = TRUE, loops = FALSE)
A <- as_adjacency_matrix(gra, sparse=FALSE)  #generate adjacency matrix
D <- diag(rowSums(A)^(-1))
D[which(D==Inf)] <- 0
W <- D%*%A                        #generate row-normalized adjacency matrix                  #generate row-normalized adjacency matrix
return(W)
}
getN = function(x,tt=1) {
if(sum(x)<tt)
return(NA)
if(x[1]>tt)
return(0)
else
return(max(which(cumsum(x)<=tt)))
}
poisson.MODpq.nonlin <- function(b, W, gamma, p, d, Z, Time, N, copula, rho, df)
{
p2R <- rho^(1:(N-1))      ### creates column vectors of corr matrix R=(rho^|i-j|)_(i,j),
R=toeplitz(c(1,p2R))      ### this is a symmetric Toeplitz matrix
y=matrix(NA, nrow=N, ncol=Time)
c=matrix(NA, nrow=N, ncol=Time)
lambda=matrix(NA, nrow=N, ncol=Time)
lambda[,1:p]=rep(1, N)
for( t in 1:p){
if(copula=="gaussian") ustart=rCopula(100, normalCopula(param=p2R, dispstr = "toep", dim=N))
if(copula=="gaussian_rho") ustart=rCopula(100, normalCopula(rho, dim = N))
if(copula=="student") ustart=rCopula(100, tCopula(param=p2R, dispstr = "toep", df=df, dim=N))
if(copula=="clayton") ustart=rCopula(100, claytonCopula(rho, dim = N))
xstart <- matrix(nrow=100, ncol=N)
xstart  =t(t(-log(ustart))/lambda[,t])
y[,t] <-  apply(xstart,2, getN, tt=1)
c[,t] <- 1/(1+W%*%y[,t])^gamma
}
for (t in (p+1):Time){
X <- cbind(W%*%y[,(t-1):(t-p)], y[,(t-1):(t-p)], Z)
lambda[,t]=b[1]*c[,t-d]+X%*%b[-1]
if(copula=="gaussian") u=rCopula(100, normalCopula(param=p2R, dispstr = "toep", dim=N))
if(copula=="gaussian_rho") u=rCopula(100, normalCopula(rho, dim = N))
if(copula=="student") u=rCopula(100, tCopula(param=p2R, dispstr = "toep", df=df, dim=N))
if(copula=="clayton") u=rCopula(100, claytonCopula(rho, dim = N))
x <- matrix(nrow=100, ncol=N)
x =t(t(-log(u))/lambda[ ,t])
y[,t] <- apply(x,2, getN,tt=1)
c[,t] <- 1/(1+W%*%y[,t])^gamma
}
res <- list(lambda=lambda, y=y, p2R=p2R)
return(res)
}
poisson.MODpq.star <- function(b, W, gamma, a, p, d, Z, Time, N, copula, rho, df)
{
p2R <- rho^(1:(N-1))      ### creates column vectors of corr matrix R=(rho^|i-j|)_(i,j),
R=toeplitz(c(1,p2R))      ### this is a symmetric Toeplitz matrix
y=matrix(NA, nrow=N, ncol=Time)
c=matrix(NA, nrow=N, ncol=Time)
lambda=matrix(NA, nrow=N, ncol=Time)
lambda[,1:p]=rep(1, N)
for( t in 1:p){
if(copula=="gaussian") ustart=rCopula(100, normalCopula(param=p2R, dispstr = "toep", dim=N))
if(copula=="gaussian_rho") ustart=rCopula(100, normalCopula(rho, dim = N))
if(copula=="student") ustart=rCopula(100, tCopula(param=p2R, dispstr = "toep", df=df, dim=N))
if(copula=="clayton") ustart=rCopula(100, claytonCopula(rho, dim = N))
xstart <- matrix(nrow=100, ncol=N)
xstart  =t(t(-log(ustart))/lambda[,t])
y[,t] <-  apply(xstart,2, getN, tt=1)
c[,t] <- exp(-gamma*(W%*%y[,t]*W%*%y[,t]))
}
for (t in (p+1):Time){
X <- cbind(1, W%*%y[,(t-1):(t-p)], y[,(t-1):(t-p)], Z)
lambda[,t]=X%*%b+c[,t-d]*W%*%y[,(t-1):(t-p)]%*%a
if(copula=="gaussian") u=rCopula(100, normalCopula(param=p2R, dispstr = "toep", dim=N))
if(copula=="gaussian_rho") u=rCopula(100, normalCopula(rho, dim = N))
if(copula=="student") u=rCopula(100, tCopula(param=p2R, dispstr = "toep", df=df, dim=N))
if(copula=="clayton") u=rCopula(100, claytonCopula(rho, dim = N))
x <- matrix(nrow=100, ncol=N)
x =t(t(-log(u))/lambda[ ,t])
y[,t] <- apply(x,2, getN,tt=1)
c[,t] <- exp(-gamma*(W%*%y[,t]*W%*%y[,t]))
}
res <- list(lambda=lambda, y=y, p2R=p2R)
return(res)
}
poisson.MODpq.tar <- function(b, W, gamma, a, p, d, Z, Time, N, copula, rho, df)
{
p2R <- rho^(1:(N-1))      ### creates column vectors of corr matrix R=(rho^|i-j|)_(i,j),
R=toeplitz(c(1,p2R))      ### this is a symmetric Toeplitz matrix
y=matrix(NA, nrow=N, ncol=Time)
c=matrix(NA, nrow=N, ncol=Time)
lambda=matrix(NA, nrow=N, ncol=Time)
lambda[,1:p]=rep(1, N)
for( t in 1:p){
if(copula=="gaussian") ustart=rCopula(100, normalCopula(param=p2R, dispstr = "toep", dim=N))
if(copula=="gaussian_rho") ustart=rCopula(100, normalCopula(rho, dim = N))
if(copula=="student") ustart=rCopula(100, tCopula(param=p2R, dispstr = "toep", df=df, dim=N))
if(copula=="clayton") ustart=rCopula(100, claytonCopula(rho, dim = N))
xstart <- matrix(nrow=100, ncol=N)
xstart  =t(t(-log(ustart))/lambda[,t])
y[,t] <-  apply(xstart,2, getN, tt=1)
c[,t] <- 0+(W%*%y[,t]<=gamma)
}
for (t in (p+1):Time){
X <- cbind(1, W%*%y[,(t-1):(t-p)], y[,(t-1):(t-p)], Z)
lambda[,t]=X%*%b+X[,1:(1+2*p)]%*%a*c[,t-d]
if(copula=="gaussian") u=rCopula(100, normalCopula(param=p2R, dispstr = "toep", dim=N))
if(copula=="gaussian_rho") u=rCopula(100, normalCopula(rho, dim = N))
if(copula=="student") u=rCopula(100, tCopula(param=p2R, dispstr = "toep", df=df, dim=N))
if(copula=="clayton") u=rCopula(100, claytonCopula(rho, dim = N))
x <- matrix(nrow=100, ncol=N)
x =t(t(-log(u))/lambda[ ,t])
y[,t] <- apply(x,2, getN,tt=1)
c[,t] <- 0+(W%*%y[,t]<=gamma)
}
res <- list(lambda=lambda, y=y, p2R=p2R)
return(res)
}
W <- adja(20, 2, 0.1)
poisson.MODpq.tar(b=c(0.5, 0.3, 0.2), W=W, gamma=0.5, a=0.2, p=1, d=1, Z=NULL,
Time=100, N=20, copula="gaussian", rho=0.5, df=1)
poisson.MODpq.tar(b=c(0.5, 0.3, 0.2), W=W, gamma=0.5, a=c(0.2, 0.2, 0.2), p=1, d=1, Z=NULL,
Time=100, N=20, copula="gaussian", rho=0.5, df=1)
