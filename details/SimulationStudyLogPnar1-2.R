
####################################################################################
## Function for running a simulation study on estimation and model selection
## of  log-linear Poisson NAR model, PNAR
####################################################################################

####Load required packages

library(igraph)
library(copula)
library(moments)
library(numDeriv)
library(nloptr)
library(car)

# requires to load the functions in the following scripts:
#  - GenerateLogPnar1.R <-- functions to generate log-linear PNAR model
#  - EstimateLogPnar1-2.R <-- functions to estimate log-linear PNAR model

#####Load required packages for parallel computing

library(foreach)
library("doMC")

registerDoMC() # register number of cores
########################

set.seed(123)


####################################################################################
####################################################################################
##  sim.log_linear() --- function generating data from log-linear Poisson 
##  NAR model, PNAR, estimating PNAR with 1 and 2 lags and compare the number of
##  times the right model is selected by information criteria.
##  Inputs:
##    N = number of nodes on the network
##    TT = temporal sample size
##    W = NxN row-normalized weighted adjacency matrix describing the network
##    b0 = intercept coefficient
##    b1 = network coefficient
##    b2 = autoregressive coefficient
##    copula =  from which copula generate the data:
##              "gaussian":      Gaussian copula with Toeplitz correlation matrix
##              "gaussian_rho":  Gaussian copula with constant correlation matrix
##              "student":       Student's t copula with Toeplitz correlation matrix
##              ... we can add more
##    rho = copula parameter
##    df = degrees of freedom for Student's t copula
##  output: two list, one for 1 lag model, one for 2 lags model containing
##    coeflin = estimated QMLE coefficients
##    selin = standard errors estimates
##    tlin = t test estimates
##    score = value of the score at the optimization point
##    aic_lin = Akaike information criterion (AIC)
##    bic_lin = Bayesian information criterion (BIC)
##    qic_lin = Quasi information criterion (QIC)
###################################################################################

sim.log_linear <- function(N, TT, W, b0, b1, b2, copula, rho, df)
{
  # generate matrix of coefficients G
  
  G <- Gmatr(b0=b0, b1=b1, b2=b2, W=W, N=N)
  
  # generate multivariate counts from the Poisson log-linear NAR(1) model
  
  y <- poisson.MOD2.log(d=G[[1]], B=G[[2]], Time=TT, N=N, copula=copula, rho=rho, df=df)$y
  
  
  # estimate log-linear models  with 1 and 2 lags
  
  ols_log1 <- ols.nar1.log(N=N, TT=TT, y=y, W=W)
  estim_log1 <- log_lin_estimnar1(x0=ols_log1, N=N, TT=TT, y=y, W=W) 
  
  ols_log2 <- ols.nar2.log(N=N, TT=TT, y=y, W=W)
  estim_log2 <- log_lin_estimnar2(x0=ols_log2, N=N, TT=TT, y=y, W=W)
  
  return(list(est1=estim_log1, est2=estim_log2))
}


######################################################################################
######################################################################################
##  LoglinearModel.Estimation1.sbm() --- function for simulation study with log-linear
##  PNAR model. The network is generated by the Stochastic Block Model (SBM).
##  Inputs:
##    N = number of nodes on the network
##    TT = temporal sample size
##    K = number of blocks of SBM
##    alpha = desired network density for SBM
##    b0 = intercept coefficient
##    b1 = network coefficient
##    b2 = autoregressive coefficient
##    copula =  from which copula generate the data:
##              "gaussian":      Gaussian copula with Toeplitz correlation matrix
##              "gaussian_rho":  Gaussian copula with constant correlation matrix
##              "student":       Student's t copula with Toeplitz correlation matrix
##              ... we can add more
##    rho = copula parameter
##    df = degrees of freedom for Student's t copula
##    sim = number of simulations
##  output: a matrix where each row is the result of a simulation experiment
##    and the columns describe elements in the following order
##        - estimated QMLE coefficients model with 1 lag
##             b0, b1, b2
##        - standard errors estimates model with 1 lag
##             SE_b0, SE_b1, SE_b2
##        - t test estimates model with 1 lag
##             test_b0, test_b1, test_b2
##        - Score, AIC, BIC, QIC model with 1 lag
##        - estimated QMLE coefficients model with 2 lags
##             b0, b1, b2, b3, b4
##        - standard errors estimates model with 2 lags
##             SE_b0, SE_b1, SE_b2, SE_b3, SE_b4,
##        - t test estimates model with 1 lag
##             test_b0, test_b1, test_b2, test_b3, test_b4
##        - Score, AIC, BIC, QIC model with 2 lags
######################################################################################

# <--- IMPORTANT with parallel computing select %dopar% instead of %do%

LoglinearModel.Estimation1.sbm <- function(N, TT, K, alpha, b0, b1, b2, copula, rho, df, sim)
{
  W <- adja(N=N, K=K, alpha=alpha)
  simulation.test=foreach(i=1:sim,.inorder=TRUE, .errorhandling="remove", .combine='rbind')%do%
    {
      cat("\n\n********** Now doing iteration",i,"of", sim, "**********\n\n")	
      results=unlist(sim.log_linear(N, TT, W, b0, b1, b2, copula, rho, df), use.names=FALSE)
      return(results)
    }
  return(simulation.test)
}

####################### Results ###############################

####### Small N, large TT
out1 <- LoglinearModel.Estimation1.sbm(N=20, TT=100, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0.5, df=1, sim=1000)
out2 <- LoglinearModel.Estimation1.sbm(N=20, TT=200, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0.5, df=1, sim=1000)
out3 <- LoglinearModel.Estimation1.sbm(N=20, TT=100, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0.9, df=1, sim=1000)
out4 <- LoglinearModel.Estimation1.sbm(N=20, TT=200, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0.9, df=1, sim=1000)
out5 <- LoglinearModel.Estimation1.sbm(N=20, TT=100, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0, df=1, sim=1000)
out6 <- LoglinearModel.Estimation1.sbm(N=20, TT=200, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0, df=1, sim=1000)
####### Large N large TT
out7 <- LoglinearModel.Estimation1.sbm(N=100, TT=100, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0.5, df=1, sim=1000)
out8 <- LoglinearModel.Estimation1.sbm(N=100, TT=200, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0.5, df=1, sim=1000)
out9 <- LoglinearModel.Estimation1.sbm(N=100, TT=100, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0.9, df=1, sim=1000)
out10 <- LoglinearModel.Estimation1.sbm(N=100, TT=200, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0.9, df=1, sim=1000)
out11 <- LoglinearModel.Estimation1.sbm(N=100, TT=100, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0, df=1, sim=1000)
out12 <- LoglinearModel.Estimation1.sbm(N=100, TT=200, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0, df=1, sim=1000)
####### Large N small TT
out13 <- LoglinearModel.Estimation1.sbm(N=100, TT=20, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0.5, df=1, sim=1000)
out14 <- LoglinearModel.Estimation1.sbm(N=100, TT=50, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0.5, df=1, sim=1000)
out15 <- LoglinearModel.Estimation1.sbm(N=100, TT=20, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0.9, df=1, sim=1000)
out16 <- LoglinearModel.Estimation1.sbm(N=100, TT=50, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0.9, df=1, sim=1000)
out17 <- LoglinearModel.Estimation1.sbm(N=100, TT=20, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0, df=1, sim=1000)
out18 <- LoglinearModel.Estimation1.sbm(N=100, TT=50, K=5, alpha=1, b0=0.2, b1=0.3, b2=0.2, copula="gaussian", rho=0, df=1, sim=1000)

save.image("SimulationStudyLogPNAR.Rdata") # <--- IMPORTANT; do not forget with parallel computing
