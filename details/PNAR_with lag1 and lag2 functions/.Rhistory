con <- sum( b[2:(2 * p + 1)] ) -1
return(con)
}
# Jacobian of constraints
# b are the parameters to be constrained
j_constr <- function(b, N, TT, y, W, wy, p, Z) {
j_con <- rep(1, m)
j_con[1] <- 0
return(j_con)
}
# algorithm and relative tolerance
opts <- list( "algorithm" = "NLOPT_LD_SLSQP", "xtol_rel" = 1.0e-8 )
s_qmle <- nloptr::nloptr(x0 = x0, eval_f = logl_linpq, eval_grad_f = scor_linpq,
lb = lb, ub = ub, eval_g_ineq = constr, eval_jac_g_ineq = j_constr,
opts = opts, N = N, TT = TT, y = y, W = W, wy = wy, p = p, Z = Z)
coeflin <- s_qmle$solution
################################################################################
## Function for estimating linear Poisson NAR model with p lags, PNAR(p),
## and q non time-varying covariates
################################################################################
################################################################################
################################################################################
##  logl_linpq() --- function for the computation of log-likelihood of the linear
##  PNAR model with p lags and q covariates. Inputs:
##     b = parameters of the models in the following order:
##        (intercept, p network effects, p ar effects, covariates)
##     N = number of nodes on the network
##     TT = temporal sample size
##     y = NxTT multivariate count time series
##     W = NxN row-normalized weighted adjacency matrix describing the network
##     p = number of lags in the model
##     Z = Nxq matrix of covariates (one for each column), where q is the number of
##         covariates in the model. They must be non-negative
##  output:
##     g = (-1)* independence quasi log-likelihood
################################################################################
logl_linpq <- function(b, N, TT, y, W, wy, p, Z) {
lambdat <- as.vector(wy %*% b)
- sum( as.vector( y[, -c(1:p)] ) * log(lambdat) - lambdat )
}
################################################################################
################################################################################
##  scor_linpq() --- function for the computation of score of the linear
##  PNAR model with p lags and q covariates. Inputs:
##     b = parameters of the models in the following order:
##        (intercept, p network effects, p ar effects, covariates)
##     N = number of nodes on the network
##     TT = temporal sample size
##     y = NxTT multivariate count time series
##     W = NxN row-normalized weighted adjacency matrix describing the network
##     p = number of lags in the model
##     Z = Nxq matrix of covariates (one for each column), where q is the number of
##         covariates in the model. They must be non-negative
##  output:
##     ss = (-1)* vector of quasi score
################################################################################
scor_linpq <- function(b, N, TT, y, W, wy, p, Z) {
lambdat <- as.vector( wy %*% b)
a <-  - Rfast::eachcol.apply(wy, ( as.vector(y[, -c(1:p)]) - lambdat ) / lambdat )
matrix(a, 2 * p + 1, 1)
}
################################################################################
################################################################################
##  hess_linpq() --- function for the computation of Hessian matrix of the
##  linear PNAR model with p lags and q covariates. Inputs:
##     b = parameters of the models
##     N = number of nodes on the network
##     TT = temporal sample size
##     y = NxTT multivariate count time series
##     W = NxN row-normalized weighted adjacency matrix describing the network
##     p = number of lags in the model
##     Z = Nxq matrix of covariates (one for each column), where q is the number of
##         covariates in the model. They must be non-negative
##  output:
##     hh = (-1)*Hessian matrix
################################################################################
################################################################################
################################################################################
##  outer_linpq() --- function for the computation of information matrix of the
##  linear PNAR model with p lags and q covariates. Inputs:
##     b = parameters of the models
##     N = number of nodes on the network
##     TT = temporal sample size
##     y = NxTT multivariate count time series
##     W = NxN row-normalized weighted adjacency matrix describing the network
##     p = number of lags in the model
##     Z = Nxq matrix of covariates (one for each column), where q is the number of
##         covariates in the model. They must be non-negative
##  output:
##     out = information matrix
################################################################################
scor_hess_outer_linpq <- function(b, N, TT, y, wy, p, Z) {
## scor
lambdat <- as.vector( wy %*% b)
a <- wy * ( as.vector(y[, -c(1:p)]) - lambdat ) / lambdat
scor <- matrix( - Rfast::colsums(a), 2 * p + 1, 1 )
## hess
ct <- as.vector(y[, -(1:p)]) / lambdat^2
hh <- crossprod( wy * ct, wy )
## outer
out <- 0
k <- rep( 1:c(TT - p), each = N )
b1 <- rowsum(a, k)
for (i in 1: c(TT - p) )  out1 <- out1 + tcrossprod(b1[i, ])
list(scor = scor, hh = hh, out = out)
}
################################################################################
################################################################################
##  lin_estimnarpq() --- function for the constrained estimation of linear PNAR
##  model with p lags and q covariates. Inputs:
##    x0 = starting value of the optimization
##    N = number of nodes on the network
##    TT = temporal sample size
##    y = NxTT multivariate count time series
##    W = NxN row-normalized weighted adjacency matrix describing the network
##    p = number of lags in the model
##    Z = Nxq matrix of covariates (one for each column), where q is the number of
##        covariates in the model. They must be non-negative
##  output:
##    coeflin = estimated QMLE coefficients
##    selin = standard errors estimates
##    tlin = t test estimates
##    score = value of the score at the optimization point
##    aic_lin = Akaike information criterion (AIC)
##    bic_lin = Bayesian information criterion (BIC)
##    qic_lin = Quasi information criterion (QIC)
############
if ( min(W) < 0 ) {
stop('The adjacency matrix W contains negative values.')
}
W <- W / Rfast::rowsums(W)
W[ is.na(W) ] <- 0
dm <- dim(y)   ;    N <- dm[1]    ;    TT <- dm[2]
z <- W %*% y
wy <- NULL
for ( ti in (p + 1):TT )  wy <- rbind( wy, cbind(z[, (ti - 1):(ti - p)], y[, (ti - 1):(ti - p)], Z) )
wy <- cbind(1, wy)
XX <- crossprod(wy)
Xy <- Rfast::eachcol.apply(wy, as.vector( y[, -c(1:p)] ) )
x0 <- solve(XX, Xy)
x0[x0 < 0] <- 0.001
m <- length(x0)
# Lower and upper bounds (positivity constraints)
lb <- rep(0, m)
ub <- rep(Inf, m)
# Inequality constraints (parameters searched in the stationary region)
# b are the parameters to be constrained
constr <- function(b, N, TT, y, W, wy, p, Z) {
con <- sum( b[2:(2 * p + 1)] ) -1
return(con)
}
# Jacobian of constraints
# b are the parameters to be constrained
j_constr <- function(b, N, TT, y, W, wy, p, Z) {
j_con <- rep(1, m)
j_con[1] <- 0
return(j_con)
}
# algorithm and relative tolerance
opts <- list( "algorithm" = "NLOPT_LD_SLSQP", "xtol_rel" = 1.0e-8 )
s_qmle <- nloptr::nloptr(x0 = x0, eval_f = logl_linpq, eval_grad_f = scor_linpq,
lb = lb, ub = ub, eval_g_ineq = constr, eval_jac_g_ineq = j_constr,
opts = opts, N = N, TT = TT, y = y, W = W, wy = wy, p = p, Z = Z)
coeflin <- s_qmle$solution
ola <- scor_hess_outer_linpq(coeflin, N, TT, y, wy, p, Z)
scor_hess_outer_linpq <- function(b, N, TT, y, wy, p, Z) {
## scor
lambdat <- as.vector( wy %*% b)
a <- wy * ( as.vector(y[, -c(1:p)]) - lambdat ) / lambdat
scor <- matrix( - Rfast::colsums(a), 2 * p + 1, 1 )
## hess
ct <- as.vector(y[, -(1:p)]) / lambdat^2
hh <- crossprod( wy * ct, wy )
## outer
#out1 <- 0
k <- rep( 1:c(TT - p), each = N )
b1 <- rowsum(a, k)
#for (i in 1: c(TT - p) )  out1 <- out1 + tcrossprod(b1[i, ])
out1 <- crossprod(b1)
list(scor = scor, hh = hh, out = out1)
}
ola2 <- scor_hess_outer_linpq(coeflin, N, TT, y, wy, p, Z)
ola$scor-ola$scor2
ola$scor
ola$scor-ola2$scor
ola$hh-ola2$hh
ola$out-ola2$out
## scor
lambdat <- as.vector( wy %*% b)
a <- wy * ( as.vector(y[, -c(1:p)]) - lambdat ) / lambdat
scor <- matrix( - Rfast::colsums(a), 2 * p + 1, 1 )
## hess
ct <- as.vector(y[, -(1:p)]) / lambdat^2
hh <- crossprod( wy * ct, wy )
## outer
#out1 <- 0
k <- rep( 1:c(TT - p), each = N )
b1 <- rowsum(a, k)
#for (i in 1: c(TT - p) )  out1 <- out1 + tcrossprod(b1[i, ])
out1 <- crossprod(b1)
b
b=coeflin
N
TT
y
Wy
wy
p
Z
## scor
lambdat <- as.vector( wy %*% b)
a <- wy * ( as.vector(y[, -c(1:p)]) - lambdat ) / lambdat
scor <- matrix( - Rfast::colsums(a), 2 * p + 1, 1 )
## hess
ct <- as.vector(y[, -(1:p)]) / lambdat^2
hh <- crossprod( wy * ct, wy )
## outer
#out1 <- 0
k <- rep( 1:c(TT - p), each = N )
b1 <- rowsum(a, k)
#for (i in 1: c(TT - p) )  out1 <- out1 + tcrossprod(b1[i, ])
out1 <- crossprod(b1)
dim(b1)
## outer
out1 <- 0
k <- rep( 1:c(TT - p), each = N )
b1 <- rowsum(a, k)
for (i in 1: c(TT - p) )  out1 <- out1 + tcrossprod(b1[i, ])
out1-ola$out
ola
scor_hess_outer_linpq(coeflin, N, TT, y, wy, p, Z)
ola$out
source('C:/Users/Michail/Desktop/Folder/Fokianos/Time series network/R package PNAR/PNAR/R/lin_estimnarpq.R')
ola=scor_hess_outer_linpq(coeflin, N, TT, y, wy, p, Z)
ola
mod
a
ola
b
## scor
lambdat <- as.vector( wy %*% b)
a <- wy * ( as.vector(y[, -c(1:p)]) - lambdat ) / lambdat
scor <- matrix( - Rfast::colsums(a), 2 * p + 1, 1 )
## hess
ct <- as.vector(y[, -(1:p)]) / lambdat^2
hh <- crossprod( wy * ct, wy )
## outer
out1 <- 0
k <- rep( 1:c(TT - p), each = N )
b1 <- rowsum(a, k)
for (i in 1: c(TT - p) )  out1 <- out1 + tcrossprod(b1[i, ])
## out1 <- crossprod(b1)
ola$out-out1
crossprod(b1)
ola$out
scor_hess_outer_linpq <- function(b, N, TT, y, wy, p, Z) {
## scor
lambdat <- as.vector( wy %*% b)
a <- wy * ( as.vector(y[, -c(1:p)]) - lambdat ) / lambdat
scor <- matrix( - Rfast::colsums(a), 2 * p + 1, 1 )
## hess
ct <- as.vector(y[, -(1:p)]) / lambdat^2
hh <- crossprod( wy * ct, wy )
## outer
#out1 <- 0
k <- rep( 1:c(TT - p), each = N )
b1 <- rowsum(a, k)
#for (i in 1: c(TT - p) )  out1 <- out1 + tcrossprod(b1[i, ])
## out1 <- crossprod(b1)
list(scor = scor, hh = hh, out = out1)
}
ola2 <- scor_hess_outer_linpq(coeflin, N, TT, y, wy, p, Z)
ola$out-ola2$out
ola2
scor_hess_outer_linpq()
scor_hess_outer_linpq
## scor
lambdat <- as.vector( wy %*% b)
a <- wy * ( as.vector(y[, -c(1:p)]) - lambdat ) / lambdat
scor <- matrix( - Rfast::colsums(a), 2 * p + 1, 1 )
## hess
ct <- as.vector(y[, -(1:p)]) / lambdat^2
hh <- crossprod( wy * ct, wy )
## outer
#out1 <- 0
k <- rep( 1:c(TT - p), each = N )
b1 <- rowsum(a, k)
#for (i in 1: c(TT - p) )  out1 <- out1 + tcrossprod(b1[i, ])
out1 <- crossprod(b1)
out1-ola$out
scor_hess_outer_linpq <- function(b, N, TT, y, wy, p, Z) {
## scor
lambdat <- as.vector( wy %*% b)
a <- wy * ( as.vector(y[, -c(1:p)]) - lambdat ) / lambdat
scor <- matrix( - Rfast::colsums(a), 2 * p + 1, 1 )
## hess
ct <- as.vector(y[, -(1:p)]) / lambdat^2
hh <- crossprod( wy * ct, wy )
## outer
out1 <- 0
k <- rep( 1:c(TT - p), each = N )
b1 <- rowsum(a, k)
for (i in 1: c(TT - p) )  out1 <- out1 + tcrossprod(b1[i, ])
#out1 <- crossprod(b1)
list(scor = scor, hh = hh, out = out1)
}
ola <- scor_hess_outer_linpq(coeflin, N, TT, y, wy, p, Z)
ola$out
lambdat <- as.vector( wy %*% b)
a <- wy * ( as.vector(y[, -c(1:p)]) - lambdat ) / lambdat
scor <- matrix( - Rfast::colsums(a), 2 * p + 1, 1 )
## hess
ct <- as.vector(y[, -(1:p)]) / lambdat^2
hh <- crossprod( wy * ct, wy )
## outer
out1 <- 0
k <- rep( 1:c(TT - p), each = N )
b1 <- rowsum(a, k)
out1 <- crossprod(b1)
scor-ola$scor
hh-ola$hh
out1-ola$out
p=3
if ( min(W) < 0 ) {
stop('The adjacency matrix W contains negative values.')
}
W <- W / Rfast::rowsums(W)
W[ is.na(W) ] <- 0
dm <- dim(y)   ;    N <- dm[1]    ;    TT <- dm[2]
ly <- log1p(y)
z <- W %*% ly
wy <- NULL
for ( ti in (p + 1):TT )  wy <- rbind( wy, cbind(z[, (ti - 1):(ti - p)], ly[, (ti - 1):(ti - p)], Z) )
wy <- cbind(1, wy)
XX <- crossprod(wy)
Xy <- Rfast::eachcol.apply(wy, as.vector( ly[, -c(1:p)] ) )
x0 <- solve(XX, Xy)
m <- length(x0)
# Inequality constraints (parameters searched in the stationary region)
# b are the parameters to be constrained
constr <- function(b, N, TT, y, W, wy, p, Z) {
con <- sum( abs( b[2:(2 * p + 1)] ) ) - 1
return(con)
}
# Jacobian of constraints
# b are the parameters to be constrained
j_constr <- function(b, N, TT, y, W, wy, p, Z) {
j_con <- b/abs(b)
j_con[1] <- 0
return(j_con)
}
# algorithm and and relative tolerance
opts <- list("algorithm" = "NLOPT_LD_SLSQP", "xtol_rel" = 1e-8)
s_qmle <- nloptr(x0 = x0, eval_f = logl_log_linpq, eval_grad_f = scor_logpq,
eval_g_ineq = constr, eval_jac_g_ineq = j_constr,
opts = opts, N = N, TT = TT, y = y, W = W, wy = wy, p = p, Z = Z)
coeflin <- s_qmle$solution
s_qmle <- nloptr::nloptr(x0 = x0, eval_f = logl_log_linpq, eval_grad_f = scor_logpq,
eval_g_ineq = constr, eval_jac_g_ineq = j_constr,
opts = opts, N = N, TT = TT, y = y, W = W, wy = wy, p = p, Z = Z)
coeflin <- s_qmle$solution
################################################################################
## Function for estimating log-linear Poisson NAR model with p lags, PNAR(p),
## and q non time-varying covariates
################################################################################
################################################################################
################################################################################
##  logl_log_linpq() --- function for the computation of log-likelihood of the
##  log-linear PNAR model with p lags and q covariates. Inputs:
##     b = parameters of the models in the following order:
##         (intercept, p network effects, p ar effects, covariates)
##     N = number of nodes on the network
##     TT = temporal sample size
##     y = NxTT multivariate count time series
##     W = NxN row-normalized weighted adjacency matrix describing the network
##     p = number of lags in the model
##     Z = Nxq matrix of covariates (one for each column), where q is the number of
##         covariates in the model.
##  output:
##     g = (-1)* independence quasi log-likelihood
################################################################################
logl_log_linpq <- function(b, N, TT, y, W, wy, p, Z) {
nut <- as.vector( wy %*% b)
- sum( as.vector( y[, -c(1:p)] ) * nut - exp(nut) )
}
################################################################################
################################################################################
##  scor_logpq() --- function for the computation of score of the
##  log-linear PNAR model with p lags and q covariates. Inputs:
##     b = parameters of the models in the following order:
##         (intercept, p network effects, p ar effects, covariates)
##     N = number of nodes on the network
##     TT = temporal sample size
##     y = NxTT multivariate count time series
##     W = NxN row-normalized weighted adjacency matrix describing the network
##     p = number of lags in the model
##     Z = Nxq matrix of covariates (one for each column), where q is the number of
##         covariates in the model.
##  output:
##     ss = (-1)* vector of quasi score
################################################################################
scor_logpq <- function(b, N, TT, y, W, wy, p, Z) {
nut <- as.vector( wy %*% b)
a <-  - Rfast::eachcol.apply(wy, as.vector( y[, -c(1:p)] ) - exp(nut) )
matrix(a, 2 * p + 1, 1)
}
################################################################################
################################################################################
##  hess_logpq() --- function for the computation of Hessian matrix of the
##  log-linear PNAR model with p lags and q covariates. Inputs:
##     b = parameters of the models
##     N = number of nodes on the network
##     TT = temporal sample size
##     y = NxTT multivariate count time series
##     W = NxN row-normalized weighted adjacency matrix describing the network
##     p = number of lags in the model
##     Z = Nxq matrix of covariates (one for each column), where q is the number of
##         covariates in the model.
##  output:
##     hh = (-1)*Hessian matrix
################################################################################
################################################################################
################################################################################
##  outer_logpq() --- function for the computation of information matrix of the
##  log-linear PNAR model with p lags and q covariates. Inputs:
##     b = parameters of the models
##     N = number of nodes on the network
##     TT = temporal sample size
##     y = NxTT multivariate count time series
##     W = NxN row-normalized weighted adjacency matrix describing the network
##     p = number of lags in the model
##     Z = Nxq matrix of covariates (one for each column), where q is the number of
##         covariates in the model.
##  output:
##     out = information matrix
################################################################################
scor_hess_outer_logpq <- function(b, N, TT, y, wy, p, Z) {
## scor
nut <- as.vector( wy %*% b)
a <- wy * ( as.vector( y[, -c(1:p)] ) - exp(nut) )
scor <- matrix( - Rfast::colsums(a), 2 * p + 1, 1)
## hess
nut <- as.vector( wy %*% b )
hh <- crossprod( wy * exp(nut), wy )
## outer
out_log <- 0
k <- rep( 1:c(TT - p), each = N )
be <- rowsum(a, k)
for ( i in 1: c(TT - p) )  out_log <- out_log + tcrossprod(be[i, ])
list(scor = scor, hh = hh, out = out_log)
}
################################################################################
################################################################################
##  log_lin_estimnarpq() --- function for the constrained estimation of
##  log-linear PNAR model with p lags and q covariates. Inputs:
##    x0 = starting value of the optimization
##    N = number of nodes on the network
##    TT = temporal sample size
##    y = NxTT multivariate count time series
##    W = NxN row-normalized weighted adjacency matrix describing the network
##    p = number of lags in the model
##    Z = Nxq matrix of covariates (one for each column), where q is the number of
##         covariates in the model.
##  output:
##    coeflin = estimated QMLE coefficients
##    selin = standard errors estimates
##    tlin = t test estimates
##    score = value of the score at the optimization point
##    aic_lin = Akaike informa
s_qmle <- nloptr::nloptr(x0 = x0, eval_f = logl_log_linpq, eval_grad_f = scor_logpq,
eval_g_ineq = constr, eval_jac_g_ineq = j_constr,
opts = opts, N = N, TT = TT, y = y, W = W, wy = wy, p = p, Z = Z)
coeflin <- s_qmle$solution
coeflin
b=coeflin
ola <- scor_hess_outer_logpq(coeflin, N, TT, y, wy, p, Z)
## scor
nut <- as.vector( wy %*% b)
a <- wy * ( as.vector( y[, -c(1:p)] ) - exp(nut) )
scor <- matrix( - Rfast::colsums(a), 2 * p + 1, 1)
## hess
nut <- as.vector( wy %*% b )
hh <- crossprod( wy * exp(nut), wy )
## outer
ola$scor-scor
ola
ola$hh-hh
k <- rep( 1:c(TT - p), each = N )
be <- rowsum(a, k)
crossprod(be)-ola$out
library(PNAR)
library(PNAR)
library(PNAR)
source('C:/Users/Michail/Desktop/Folder/Fokianos/Time series network/R package PNAR/PNAR/R/score_test_nonlinpq_h0.R', encoding = 'UTF-8')
source('C:/Users/Michail/Desktop/Folder/Fokianos/Time series network/R package PNAR/PNAR/R/score_test_nonlinpq_h0.R')
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
library(PNAR)
